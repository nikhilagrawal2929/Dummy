import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

@Service
public class CSVReaderService {

    @Value("${csv.folder.path}")
    private String csvFolderPath;

    public Map<String, CSVData> readMultipleCSVs(String[] fileNames) {
        Map<String, CSVData> csvDataMap = new HashMap<>();
        ExecutorService executorService = Executors.newCachedThreadPool();

        try {
            List<Future<?>> futures = new ArrayList<>();
            for (String fileName : fileNames) {
                Future<?> future = executorService.submit(() -> {
                    try {
                        File file = new File(csvFolderPath, fileName);
                        CSVReader reader = new CSVReader(new FileReader(file));

                        // Read headers
                        String[] headers = reader.readNext();

                        // Read data rows
                        List<String[]> records = new ArrayList<>();
                        String[] record;
                        while ((record = reader.readNext()) != null) {
                            records.add(record);
                        }
                        CSVData csvData = new CSVData();
                        csvData.setHeaders(headers);
                        csvData.setData(records);

                        synchronized (csvDataMap) {
                            csvDataMap.put(fileName, csvData);
                        }

                        reader.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
                futures.add(future);
            }

            // Wait for all tasks to complete
            for (Future<?> future : futures) {
                future.get();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }

        return csvDataMap;
    }
}
